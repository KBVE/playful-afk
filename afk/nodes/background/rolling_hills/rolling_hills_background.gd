extends Control
class_name RollingHillsBackground

## Simple layered background using TextureRect nodes
## 4 layers with parallax scrolling for rolling hills environment

@export var scroll_speed_layer1: float = 0.15
@export var scroll_speed_layer2: float = 0.35
@export var scroll_speed_layer3: float = 0.6
@export var scroll_speed_layer4: float = 0.9

@onready var layer1: TextureRect = $Layer1
@onready var layer2: TextureRect = $Layer2
@onready var layer3: TextureRect = $Layer3
@onready var layer4: TextureRect = $Layer4
@onready var layer3_objects: Node2D = $Layer3Objects
@onready var layer4_objects: Node2D = $Layer4Objects

var scroll_offset: float = 0.0
var initial_layer3_objects_position: float = 0.0
var initial_layer4_objects_position: float = 0.0

## Original background image dimensions (640x384)
const BG_IMAGE_WIDTH: int = 640
const BG_IMAGE_HEIGHT: int = 384

## Heightmap configuration (static - never changes)
## The shader scales based on screen height: 648 / 384 = 1.6875
const TILE_SCALE: float = 1.6875  # Actual scale from shader (screen_height / texture_height)

## Safe boundary curve (Fourier series fitted to terrain)
## This curve stays slightly ABOVE all terrain points (2px margin) - NPCs should be BELOW it (Y > boundary_y)
## Generated by extract_bounds_rgb.py using terrain analysis
func get_safe_boundary_y_image_space(x: float) -> float:
	"""Get the safe boundary Y in image space (640x384) for a given X"""
	var freq = 2.0 * PI / 640.0
	return (271.903125 +
			-23.301847 * cos(freq * x) + 10.365967 * sin(freq * x) +
			-4.567788 * cos(2.0 * freq * x) + 1.452695 * sin(2.0 * freq * x) +
			-0.334323 * cos(3.0 * freq * x) + 8.933629 * sin(3.0 * freq * x))

## Walkable polygon shape (screen coordinates) - generated in _ready()
var walkable_polygon: PackedVector2Array = []

## Debug visualization toggle (set to true to see the walkable polygon)
var show_debug_polygon: bool = false

## Debug overlay node for drawing on top of everything
var debug_overlay: Control = null


func _ready() -> void:
	# Store initial position for objects containers
	if layer3_objects:
		initial_layer3_objects_position = layer3_objects.position.x
	if layer4_objects:
		initial_layer4_objects_position = layer4_objects.position.x

	# Generate walkable polygon from heightmap
	_generate_walkable_polygon()

	# Calculate safe rectangle for fast checks
	_calculate_safe_rectangle()

	# Pre-calculate common waypoint paths
	_precalculate_waypoint_cache()

	# Create debug overlay if needed
	if show_debug_polygon:
		_create_debug_overlay()

	# Auto-register all structures with StructureManager
	_register_structures()

	print("RollingHillsBackground initialized")
	print("Walkable check mode: ", WalkableCheckMode.keys()[walkable_check_mode])


## Create a debug overlay to draw the polygon on top of everything
func _create_debug_overlay() -> void:
	debug_overlay = Control.new()
	debug_overlay.name = "DebugOverlay"
	debug_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	debug_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	add_child(debug_overlay)

	# Move to the very end so it draws on top
	move_child(debug_overlay, get_child_count() - 1)

	# Connect draw signal
	debug_overlay.draw.connect(_on_debug_overlay_draw)
	debug_overlay.queue_redraw()


## Draw the walkable polygon on the debug overlay
## The polygon represents one tile - draw multiple times to show the repeating pattern
## Offset based on scroll to match Layer4Objects movement
func _on_debug_overlay_draw() -> void:
	if not debug_overlay or walkable_polygon.is_empty():
		return

	var viewport_size = get_viewport_rect().size
	var tile_width = BG_IMAGE_WIDTH * TILE_SCALE  # 640 * 3 = 1920px

	# Calculate the scroll offset for layer 4 (0.9x speed)
	var layer4_scroll = scroll_offset * scroll_speed_layer4

	# Draw the polygon multiple times to cover the screen plus extra for scrolling
	var num_tiles = int(ceil((viewport_size.x + tile_width * 2) / tile_width))

	for tile in range(-2, num_tiles + 2):
		# Offset by tile position AND compensate for layer4 scroll
		var tile_offset = (tile * tile_width) - layer4_scroll
		var offset = Vector2(tile_offset, 0)

		# Draw the Fourier safe boundary curve in red for debugging
		var scale_y = viewport_size.y / float(BG_IMAGE_HEIGHT)

		for img_x in range(0, BG_IMAGE_WIDTH - 1, 2):
			var screen_x1 = img_x * TILE_SCALE
			var screen_x2 = (img_x + 2) * TILE_SCALE

			var img_y1 = get_safe_boundary_y_image_space(float(img_x))
			var img_y2 = get_safe_boundary_y_image_space(float(img_x + 2))

			var p1 = Vector2(screen_x1, img_y1 * scale_y) + offset
			var p2 = Vector2(screen_x2, img_y2 * scale_y) + offset
			debug_overlay.draw_line(p1, p2, Color.RED, 2.0)

		# Create offset polygon for this tile
		var offset_polygon: PackedVector2Array = []
		for point in walkable_polygon:
			offset_polygon.append(point + offset)

		# Draw polygon outline in green
		for i in range(offset_polygon.size()):
			var p1 = offset_polygon[i]
			var p2 = offset_polygon[(i + 1) % offset_polygon.size()]
			debug_overlay.draw_line(p1, p2, Color.GREEN, 3.0)

		# Draw filled polygon with transparency
		debug_overlay.draw_colored_polygon(offset_polygon, Color(0.0, 1.0, 0.0, 0.15))


## Generate a walkable polygon from the mathematical curve
## Creates a closed polygon representing the walkable area (BELOW the safe boundary curve)
## Polygon extends to screen edges for a perfect walkable shape
func _generate_walkable_polygon() -> void:
	var viewport_size = get_viewport_rect().size
	var scale_y = viewport_size.y / float(BG_IMAGE_HEIGHT)
	var tile_width = BG_IMAGE_WIDTH * TILE_SCALE  # 640 * 1.6875 = 1080px

	# Start with an empty array
	var points: PackedVector2Array = []

	# Trace the Fourier curve from left to right (this is the TOP boundary)
	for img_x in range(0, BG_IMAGE_WIDTH + 1, 10):
		# Convert from image X to screen X
		var screen_x = img_x * TILE_SCALE

		# Get the safe boundary Y value in image space using the Fourier curve
		var img_y = get_safe_boundary_y_image_space(float(img_x))

		# Convert to screen space
		var screen_y = img_y * scale_y

		# Add point along the curve
		points.append(Vector2(screen_x, screen_y))

	# Now close the polygon: go down to bottom-right, across bottom, up to start
	points.append(Vector2(tile_width, viewport_size.y))  # Bottom-right
	points.append(Vector2(0, viewport_size.y))  # Bottom-left
	# Polygon auto-closes back to first point

	walkable_polygon = points
	print("Generated walkable polygon with ", walkable_polygon.size(), " points (Fourier curve)")
	print("Polygon covers X: 0 to ", tile_width, " Y: curve to ", viewport_size.y)
	print("Tile width: ", tile_width, " = ", BG_IMAGE_WIDTH, " * ", TILE_SCALE)


## Check if a position is inside the walkable area
## Three performance modes: RECTANGLE (fastest), FORMULA (fast), POLYGON (accurate)
enum WalkableCheckMode { RECTANGLE, FORMULA, POLYGON }
var walkable_check_mode: WalkableCheckMode = WalkableCheckMode.FORMULA

## Simple safe rectangle (below deepest terrain point)
## This is the fastest check but most restrictive
var safe_rectangle: Rect2 = Rect2()

## Path cache for common waypoint routes
## Key: "start_x,target_x" -> Value: waypoint position
var waypoint_cache: Dictionary = {}
const CACHE_GRID_SIZE: int = 50  # Cache waypoints every 50px
const MAX_CACHE_ENTRIES: int = 100

func _calculate_safe_rectangle() -> void:
	var viewport_size = get_viewport_rect().size
	var scale_y = viewport_size.y / float(BG_IMAGE_HEIGHT)
	var tile_width = BG_IMAGE_WIDTH * TILE_SCALE

	# Deepest terrain point in image space is around Y=301
	# Add small margin and convert to screen space
	var safe_y_start = 305.0 * scale_y  # ~514px in screen space

	# Bottom bound: 80px above bottom of screen (matches get_walkable_y_bounds)
	var safe_y_end = viewport_size.y - 80.0

	safe_rectangle = Rect2(0, safe_y_start, tile_width, safe_y_end - safe_y_start)
	print("Safe rectangle: ", safe_rectangle)


## Pre-calculate common waypoint paths for performance
func _precalculate_waypoint_cache() -> void:
	var tile_width = BG_IMAGE_WIDTH * TILE_SCALE

	# Generate a grid of common start/target positions
	var grid_points: Array[float] = []
	for x in range(0, int(tile_width), CACHE_GRID_SIZE):
		grid_points.append(float(x))

	# Pre-calculate waypoints for common routes
	var cache_count = 0
	for start_x in grid_points:
		for target_x in grid_points:
			if cache_count >= MAX_CACHE_ENTRIES:
				break

			# Only cache if they're reasonably far apart
			if abs(target_x - start_x) > CACHE_GRID_SIZE:
				var start_pos = Vector2(start_x, safe_rectangle.position.y)
				var target_pos = Vector2(target_x, safe_rectangle.position.y)
				var waypoint = _calculate_waypoint(start_pos, target_pos)

				# Create cache key
				var key = _get_cache_key(start_x, target_x)
				waypoint_cache[key] = waypoint
				cache_count += 1

		if cache_count >= MAX_CACHE_ENTRIES:
			break

	print("Pre-calculated ", waypoint_cache.size(), " waypoint paths")


## Get cache key for a start/target pair
func _get_cache_key(start_x: float, target_x: float) -> String:
	# Round to grid to increase cache hits
	var grid_start = int(start_x / CACHE_GRID_SIZE) * CACHE_GRID_SIZE
	var grid_target = int(target_x / CACHE_GRID_SIZE) * CACHE_GRID_SIZE
	return "%d,%d" % [grid_start, grid_target]


## Calculate waypoint (internal, not cached)
func _calculate_waypoint(start_pos: Vector2, target_pos: Vector2) -> Vector2:
	# If both positions are already in the safe rectangle, no waypoint needed
	if safe_rectangle.has_point(start_pos) and safe_rectangle.has_point(target_pos):
		return target_pos

	# Calculate a waypoint in the middle of the safe rectangle
	var waypoint_x = lerp(start_pos.x, target_pos.x, 0.5)
	waypoint_x = clamp(waypoint_x, safe_rectangle.position.x, safe_rectangle.position.x + safe_rectangle.size.x)

	# Y position in the middle of the safe zone
	var waypoint_y = safe_rectangle.position.y + safe_rectangle.size.y * 0.5

	return Vector2(waypoint_x, waypoint_y)


## Get a waypoint in the safe rectangle zone that's between start and target
## Returns a position in the guaranteed-safe zone for efficient pathfinding
## Uses cache for common routes
func get_safe_waypoint(start_pos: Vector2, target_pos: Vector2) -> Vector2:
	# Try to use cached waypoint first
	var cache_key = _get_cache_key(start_pos.x, target_pos.x)
	if waypoint_cache.has(cache_key):
		return waypoint_cache[cache_key]

	# Cache miss - calculate on the fly
	var waypoint = _calculate_waypoint(start_pos, target_pos)

	# Add to cache if we have room
	if waypoint_cache.size() < MAX_CACHE_ENTRIES:
		waypoint_cache[cache_key] = waypoint

	return waypoint


## Check if position is in the safe rectangle (fastest check)
func is_in_safe_rectangle(pos: Vector2) -> bool:
	return safe_rectangle.has_point(pos)

func is_position_in_walkable_area(pos: Vector2) -> bool:
	match walkable_check_mode:
		WalkableCheckMode.RECTANGLE:
			# Fastest: Simple rectangle check
			return safe_rectangle.has_point(pos)

		WalkableCheckMode.FORMULA:
			# Fast: Mathematical formula check
			var viewport_size = get_viewport_rect().size
			var scale_y = viewport_size.y / float(BG_IMAGE_HEIGHT)

			# Convert screen position to image space
			var img_x = fposmod(pos.x, BG_IMAGE_WIDTH * TILE_SCALE) / TILE_SCALE
			var img_y_boundary = get_safe_boundary_y_image_space(img_x)
			var screen_y_boundary = img_y_boundary * scale_y

			# NPCs must be BELOW the curve (Y > boundary_y)
			return pos.y > screen_y_boundary

		WalkableCheckMode.POLYGON:
			# Most accurate: Point-in-polygon test (slowest)
			if walkable_polygon.is_empty():
				return true  # Fallback
			return Geometry2D.is_point_in_polygon(pos, walkable_polygon)

	return false


## Register all child structures with StructureManager for auto-positioning
func _register_structures() -> void:
	if not layer3_objects or not StructureManager:
		return

	# Get all structure children
	var structures = layer3_objects.get_children()

	print("RollingHillsBackground: Found ", structures.size(), " structures to register")

	# Register each structure with the manager
	for structure in structures:
		if structure is Node2D:
			StructureManager.register_structure(structure)
			# Scale all structures using StructureManager's scale setting
			var scale = StructureManager.structure_scale
			structure.scale = Vector2(scale, scale)


## Scroll all layers based on an offset
func scroll_to(offset: float) -> void:
	scroll_offset = offset

	if layer1 and layer1.material:
		layer1.material.set_shader_parameter("scroll_offset", scroll_offset * scroll_speed_layer1)
	if layer2 and layer2.material:
		layer2.material.set_shader_parameter("scroll_offset", scroll_offset * scroll_speed_layer2)
	if layer3 and layer3.material:
		layer3.material.set_shader_parameter("scroll_offset", scroll_offset * scroll_speed_layer3)
	if layer4 and layer4.material:
		layer4.material.set_shader_parameter("scroll_offset", scroll_offset * scroll_speed_layer4)

	# Also scroll objects in layer 3 at the same speed as layer 3
	if layer3_objects:
		layer3_objects.position.x = initial_layer3_objects_position - (scroll_offset * scroll_speed_layer3)

	# Scroll objects in layer 4 at the same speed as layer 4 (0.9 speed)
	if layer4_objects:
		layer4_objects.position.x = initial_layer4_objects_position - (scroll_offset * scroll_speed_layer4)

	# Redraw debug overlay when scrolling
	if debug_overlay and show_debug_polygon:
		debug_overlay.queue_redraw()


## Reset scroll
func reset() -> void:
	scroll_to(0.0)


## Get walkable Y bounds at a specific screen X position using the Fourier curve
## Returns Vector2(min_y, max_y) where NPCs can walk
func get_walkable_y_bounds(screen_x: float) -> Vector2:
	var viewport_size = get_viewport_rect().size
	var scale_y = viewport_size.y / float(BG_IMAGE_HEIGHT)

	# Convert screen X to image space (handle tiling)
	var img_x = fposmod(screen_x, BG_IMAGE_WIDTH * TILE_SCALE) / TILE_SCALE

	# Get the safe boundary Y from the Fourier curve (in image space)
	var boundary_y_img = get_safe_boundary_y_image_space(img_x)

	# Convert to screen space
	var boundary_y_screen = boundary_y_img * scale_y

	# Return range: from the boundary down to a reasonable bottom margin
	# NPCs should be BELOW the boundary (Y > boundary_y)
	# Keep them well above the bottom of screen (80px margin)
	return Vector2(boundary_y_screen, viewport_size.y - 80.0)
